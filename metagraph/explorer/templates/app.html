<div id="{DIV_ID}" />

<script> // Globals

  /*******************/
  /* Misc. Utilities */
  /*******************/
  
  var sum = inputArray => inputArray.reduce((a, b) => a + b, 0);
  var mean = inputArray => sum(inputArray) / inputArray.length;

  var callAfterDOMUpdated = (func) => {
      // Calls function after the DOM is updated to prevent non-deterministic results when grabbing element attributes, e.g. height, during transitions and animations
      const intermediateFunc = () => window.requestAnimationFrame(func);
      window.requestAnimationFrame(intermediateFunc);
  };

  /**************/
  /* General UI */
  /**************/
  
  var metagraphActivateExplorerTab = (clickedElement, explorerTabId) => {
      const explorerBody = clickedElement.closest('#mg-explorer-body');
      for (const navigationBarLi of explorerBody.querySelectorAll(`#mg-explorer-navigation-bar li`)) {
          navigationBarLi.classList.remove('active');
      }
      clickedElement.classList.add('active');
      for (const explorerTab of explorerBody.querySelectorAll('.mg-explorer-tab')) {
          explorerTab.classList.remove('active');
      }
      const currentExplorerTab = explorerBody.querySelector(`#${explorerTabId}`);
      currentExplorerTab.classList.add('active');
  };
  
</script>

<script> // Initializations
  
  (({port, divId, shadowInnerHTML, plugins, abstractTypes}) => {

      /******************************/
      /* Shadow DOM Initializations */
      /******************************/
      
      const div = document.getElementById(divId);
      let shadow = div.attachShadow({mode: 'open'});
      shadow.innerHTML = shadowInnerHTML;

      /************/
      /* POC Code */
      /************/

      const buildTree = function(root, data, topLevel) {
	  if (topLevel) {
              root.innerHTML = "";
              const treeWidgetDiv = document.createElement('div');
              treeWidgetDiv.className = 'treewidget';
              root.appendChild(treeWidgetDiv);
              const ul = document.createElement('ul');
              treeWidgetDiv.appendChild(ul);
              buildTree(ul, data, false);
              
              const toggler = root.getElementsByClassName("caret");
              for (let i = 0; i < toggler.length; i++) {
		  toggler[i].addEventListener("click", function() {
                      this.parentElement.querySelector(".nested").classList.toggle("active");
                      this.classList.toggle("caret-down");
		  });
              }
	  } else {
              for (let name in data) {
		  if (data.hasOwnProperty(name)) {
                      const li = document.createElement('li');
                      const props = data[name];
                      if ('children' in props) {
			  const caret = document.createElement('span');
			  caret.className = 'caret';
			  caret.innerHTML = name;
			  li.appendChild(caret);
			  const ul = document.createElement('ul');
			  ul.className = 'nested';
			  li.appendChild(ul);
			  root.appendChild(li);
			  buildTree(ul, props['children'], false);
                      } else {
			  li.innerHTML = name;
			  root.appendChild(li);
                      }
		  }
              }
	  }
      }

      shadow.close = shadow.querySelector(".close");
      shadow.viewTypes = shadow.querySelector("#viewTypeTypes1");
      shadow.viewTranslators = shadow.querySelector("#viewTypeTranslators2");
      shadow.viewAlgorithms = shadow.querySelector("#viewTypeAlgorithms3");
      shadow.pluginsDropDown = shadow.querySelector('#pluginsDropDown');
      shadow.abstractDropDown = shadow.querySelector('#abstractDropDown');
      shadow.display = shadow.querySelector("#display");
      shadow.websocket = new WebSocket(`ws://127.0.0.1:${port}/`);
      // Add back-reference on websocket
      shadow.websocket.owner = shadow;

      plugins.forEach(function(plug) {
	  const op = document.createElement('option');
	  op.value = plug;
	  op.innerHTML = plug;
	  shadow.pluginsDropDown.appendChild(op);
      });
      shadow.pluginsDropDown.onchange = function(event) {
	  allHandler(this.getRootNode());
      }
      
      abstractTypes.forEach(function(at) {
	  const op = document.createElement('option');
	  op.value = at;
	  op.innerHTML = at;
	  shadow.abstractDropDown.appendChild(op);
      });
      shadow.abstractDropDown.onchange = function(event) {
	  allHandler(this.getRootNode());
      }

      const radioHandler = function (event) {
	  var shadow = this.getRootNode();
	  if (shadow.viewTranslators.checked) {
              shadow.abstractDropDown.parentElement.style.visibility = null;
	  } else {
              shadow.abstractDropDown.parentElement.style.visibility = "hidden";
	  }
	  allHandler(shadow);
      }
      shadow.viewTypes.onchange = radioHandler;
      shadow.viewTranslators.onchange = radioHandler;
      shadow.viewAlgorithms.onchange = radioHandler;
      shadow.close.onclick = function (event) {
	  root = this.getRootNode();
	  root.websocket.send(JSON.stringify({function: "close"}));
	  root.websocket.close();
	  // Remove everything as part of cleanup
	  root.innerHTML = "";
      }
      
      const allHandler = function(shadow) {
	  const kwargs = {filters: {}};
	  const pluginFilter = shadow.pluginsDropDown.value;
	  if (pluginFilter != "---") {
              kwargs['filters']['plugin'] = pluginFilter;
	  }
	  
	  if (shadow.viewTypes.checked) {
              shadow.display.innerHTML = '';
              shadow.websocket.send(JSON.stringify({function: "list_types", kwargs: kwargs}));
	  } else if (shadow.viewTranslators.checked) {
              shadow.display.innerHTML = '';
              kwargs['source_type'] = shadow.abstractDropDown.value;
              shadow.websocket.send(JSON.stringify({function: "list_translators", kwargs: kwargs}));
	  } else if (shadow.viewAlgorithms.checked) {
              shadow.display.innerHTML = '';
              shadow.websocket.send(JSON.stringify({function: "list_algorithms", kwargs: kwargs}));
	  }
      }
      
      shadow.websocket.onmessage = function (event) {
	  shadow = this.owner;
	  data = JSON.parse(event.data);
	  switch (data.function) {
	  case "list_types":
              buildTree(shadow.display, data.result, true);
              break;
	  case "list_translators":
              shadow.display.innerHTML = "";
              const treeWidgetDiv = document.createElement('div');
              treeWidgetDiv.className = "treewidget";
              shadow.display.appendChild(treeWidgetDiv);
              const ul = document.createElement('ul');
              treeWidgetDiv.appendChild(ul);
              const primary = document.createElement('li');
              primary.innerHTML = "Primary: " + data.result['primary_types'];
              ul.appendChild(primary);
              const secondary = document.createElement('li');
              secondary.innerHTML = "Secondary: " + data.result['secondary_types'];
              ul.appendChild(secondary);
              const trans = document.createElement('li');
              ul.appendChild(trans);
              const caret = document.createElement('span');
              caret.className = 'caret caret-down';
              caret.innerHTML = 'Translators'
              trans.appendChild(caret);
              const transUL = document.createElement('ul')
              transUL.className = 'nested active';
              trans.appendChild(transUL);
              for (let i = 0; i < data.result['primary_translators'].length; i++) {
		  const t = data.result['primary_translators'][i];
		  const t2 = document.createElement('li');
		  t2.innerHTML = t;
		  transUL.appendChild(t2);
              }
              caret.addEventListener("click", function() {
		  this.parentElement.querySelector(".nested").classList.toggle("active");
		  this.classList.toggle("caret-down");
              });
              break;
	  case "list_algorithms":
              buildTree(shadow.display, data.result, true);
              break;
	  default:
              console.error(
		  "unsupported event", data);
	  }
      };
      
      /*************************************/
      /* Translation Graph Initializations */
      /*************************************/
  
      require.config({paths: {d3: 'https://d3js.org/d3.v5.min'}});

      var initializeTranslationGraph = () => {
	  
	  require(['d3'], (d3) => {
              
              const graph = { // dummy data
		  nodeIdToProperties: {
                      'a': {id: 'a', description: 'This is node A.'},
                      'b': {id: 'b', description: 'This is node B.'},
                      'c': {id: 'c', description: 'This is node C.'},
                      'd': {id: 'd', description: 'This is node D.'},
		  },
		  edges: [
                      {src: 'a', dst: 'b'},
                      {src: 'b', dst: 'a'},
                      {src: 'b', dst: 'c'},
		  ],
              };
              
              // DOM Initializations
              const plotContainer = shadow.querySelector('div.mg-translation-graph-svg-container');
              const svg = d3.select(plotContainer.querySelector('svg.mg-translation-graph-svg'));        
              svg
		  .attr('width', `${plotContainer.clientWidth}px`)
		  .attr('height', `${plotContainer.clientHeight}px`);
              const svgWidth = parseFloat(svg.style('width'));
              const svgHeight = parseFloat(svg.style('height'));
              const zoomGroup = svg.append('g').attr('class', `zoom-group-${plotContainer.id}`);
              
              // Edge & Node Initializations
              const edgeGroup = zoomGroup.append('g').attr('class', `edge-group`);
              const nodeGroup = zoomGroup.append('g').attr('class', `node-group`);
              
              // Force Directed Graph Initializations
              const alphaDecay = 0.0;
              const velocityDecay = 0.9;
              const paddingBetweenNodes = 25;
              const initialLinkAlpha = 0.005;
              const linkAlphaDecay = 0.005;
              let linkAlpha = initialLinkAlpha;
              const simulation = d3.forceSimulation()
		    .alphaDecay(alphaDecay)
		    .velocityDecay(velocityDecay);
              const drag = d3.drag();
              
              // Edge Visualization
              const edgeData = graph.edges;
              const edgeEnterSelection = edgeGroup
		    .selectAll('line')
		    .data(edgeData)
		    .enter()
		    .append('line')
		    .attr('marker-end','url(#mg-translation-graph-edge-arrowhead)')
		    .attr('class', 'mg-translation-graph-edge');

              // Node Visualization
              const nodeData = Object.values(graph.nodeIdToProperties);
              const nodeEnterSelection = nodeGroup
		    .selectAll('circle')
		    .data(nodeData)
		    .enter()
		    .append('circle')
		    .attr('class', 'mg-translation-graph-node');
              const nodeForwardNeighbors = Object.keys(graph.nodeIdToProperties).reduce((accumulator, nodeId) => {
		  accumulator[nodeId] = [];
		  return accumulator;
              }, {});
              edgeData.forEach((edge) => nodeForwardNeighbors[edge.src].push(edge.dst));

              // Zoom
              const zoom = d3.zoom().on('zoom', () => {
		  zoomGroup
                      .attr('transform', d3.event.transform);
              });
              svg.call(zoom);
              
              // Force Directed Graph Visualization
              drag.on("drag", (d,i) => {
		  d.x += d3.event.dx;
		  d.y += d3.event.dy;
		  linkAlpha = initialLinkAlpha;
              });
              const linkForce = () => {
		  linkAlpha = linkAlpha * (1-linkAlphaDecay);
		  nodeData.forEach(datum => {
                      const forwardNeighborIds = nodeForwardNeighbors[datum.id];
                      const neighborIds = (forwardNeighborIds.length > 0) ? forwardNeighborIds : Object.keys(graph.nodeIdToProperties);
                      if (neighborIds.length > 0) {
			  const neighborMeanX = mean(neighborIds.map(neighborId => graph.nodeIdToProperties[neighborId].x));
			  const neighborMeanY = mean(neighborIds.map(neighborId => graph.nodeIdToProperties[neighborId].y));
			  const newX = datum.x * (1-linkAlpha) + linkAlpha * neighborMeanX;
			  const newY = datum.y * (1-linkAlpha) + linkAlpha * neighborMeanY;
			  datum.x = newX;
			  datum.y = newY;
                      }
		  });
              };
              simulation
		  .force('center', d3.forceCenter(svgWidth / 2, svgHeight / 2))
		  .force('collide', d3.forceCollide(paddingBetweenNodes).strength(0.25).iterations(200))
		  .force('links', linkForce)
		  .nodes(nodeData).on('tick', () => {
	              nodeEnterSelection
			  .attr('cx', datum => datum.x)
			  .attr('cy', datum => datum.y)
			  .call(drag);
	              edgeEnterSelection
			  .attr('x1', datum => graph.nodeIdToProperties[datum.src].x)
			  .attr('y1', datum => graph.nodeIdToProperties[datum.src].y)
			  .attr('x2', datum => graph.nodeIdToProperties[datum.dst].x)
			  .attr('y2', datum => graph.nodeIdToProperties[datum.dst].y);
		  })
		  .restart();
	  });
	  
      };
      callAfterDOMUpdated(() => initializeTranslationGraph());
      
  })({RESOLVER_DATA})
  
</script>
