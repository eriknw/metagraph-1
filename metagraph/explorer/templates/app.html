<div id="{DIV_ID}" />

<script>
  
  (({port, divId, shadowInnerHTML, abstractTypeToConcreteTypes, plugins, abstractTypes}) => {

      /*******************/
      /* Misc. Utilities */
      /*******************/
      
      const sum = inputArray => inputArray.reduce((a, b) => a + b, 0);
      const mean = inputArray => sum(inputArray) / inputArray.length;

      const removeAllChildNodes = (parent) => {
	  while (parent.firstChild) {
              parent.removeChild(parent.firstChild);
	  }
      }

      const callAfterDOMUpdated = (func) => {
	  // Calls function after the DOM is updated to prevent non-deterministic results when grabbing element attributes, e.g. height, during transitions and animations
	  const intermediateFunc = () => window.requestAnimationFrame(func);
	  window.requestAnimationFrame(intermediateFunc);
      };

      const absoluteXYOffset = (element) => {
	  const rect = element.getBoundingClientRect();
	  const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
	  const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
	  return [rect.left + scrollLeft, rect.top + scrollTop]
      }

      
      /******************************/
      /* Shadow DOM Initializations */
      /******************************/
      
      const div = document.getElementById(divId);
      const shadow = div.attachShadow({mode: 'open'});
      shadow.innerHTML = shadowInnerHTML;
      shadow.websocket = new WebSocket(`ws://127.0.0.1:${port}/`);
      shadow.websocket.onerror = () => {
	  removeAllChildNodes(shadow);
	  shadow.innerHTML = `Websocket connection to ws://127.0.0.1:${port}/ failed.`;
      };
      shadow.websocket.owner = shadow; // Add back-reference on websocket

      let highlightTranslationGraphPath = (path) => {};
      
      // Listen for websocket messagesshadow.websocket.onmessage = function (event) {
      shadow.websocket.onmessage = function (event) {
	  data = JSON.parse(event.data);
	  switch (data.function) {
	  case "list_types":
	      // below is used by POC only
              buildTree(shadow.display, data.result, true);
              break;
	  case "list_translators":
	      updateTranslationGraph(data);
	      // below is used by POC only
              shadow.display.innerHTML = "";
              const treeWidgetDiv = document.createElement('div');
              treeWidgetDiv.className = "treewidget";
              shadow.display.appendChild(treeWidgetDiv);
              const ul = document.createElement('ul');
              treeWidgetDiv.appendChild(ul);
              const primary = document.createElement('li');
              primary.innerHTML = "Primary: " + Object.keys(data.result['primary_types']);
              ul.appendChild(primary);
              const secondary = document.createElement('li');
              secondary.innerHTML = "Secondary: " + Object.keys(data.result['secondary_types']);
              ul.appendChild(secondary);
              const trans = document.createElement('li');
              ul.appendChild(trans);
              const caret = document.createElement('span');
              caret.className = 'caret caret-down';
              caret.innerHTML = 'Translators'
              trans.appendChild(caret);
              const transUL = document.createElement('ul')
              transUL.className = 'nested active';
              trans.appendChild(transUL);
              for (var pt in data.result['primary_translators']) {
                  // var t = data.result['primary_translators'][pt];
                  var t2 = document.createElement('li');
                  t2.innerHTML = pt;
                  transUL.appendChild(t2);
              }
              caret.addEventListener("click", function() {
		  this.parentElement.querySelector(".nested").classList.toggle("active");
		  this.classList.toggle("caret-down");
              });
              break;
	  case "list_algorithms":
	      // below is used by POC only
              buildTree(shadow.display, data.result, true);
              break;
	  case 'solve_translator':
	      if (data.input_kwargs.overall_abstract === abstractTypeDropdown.value) {
		  highlightTranslationGraphPath(data.result.solution);
	      }
	      break;
	  default:
              console.error('unsupported event', data);
	  }
      };
      
      /**********************************/
      /* Explorer Tab Selection Buttons */
      /**********************************/
      
      const metagraphActivateExplorerTab = (clickedElement, explorerTabId) => {
	  for (const navigationBarLi of shadow.querySelectorAll(`#mg-explorer-navigation-bar li`)) {
              navigationBarLi.classList.remove('active');
	  }
	  clickedElement.closest('li').classList.add('active');
	  for (const explorerTab of shadow.querySelectorAll('.mg-explorer-tab')) {
              explorerTab.classList.remove('active');
	  }
	  const currentExplorerTab = shadow.querySelector(`#${explorerTabId}`);
	  currentExplorerTab.classList.add('active');
      };
      
      shadow.querySelector('#mg-translation-explorer-selector').onclick = (event) => metagraphActivateExplorerTab(event.target, 'mg-translation-explorer');
      shadow.querySelector('#mg-type-explorer-selector').onclick = (event) => metagraphActivateExplorerTab(event.target, 'mg-type-explorer');
      shadow.querySelector('#mg-algorithm-explorer-selector').onclick = (event) => metagraphActivateExplorerTab(event.target, 'mg-algorithm-explorer');
      shadow.querySelector('#mg-algorithm-type-translation-explorer-selector').onclick = (event) => metagraphActivateExplorerTab(event.target, 'mg-algorithm-type-translation-explorer');
      shadow.querySelector('#mg-plugin-explorer-selector').onclick = (event) => metagraphActivateExplorerTab(event.target, 'mg-plugin-explorer');
      
      const metagraphCloseExplorer = () => {
	  shadow.websocket.send(JSON.stringify({function: 'close'}));
	  shadow.websocket.close();
	  removeAllChildNodes(shadow);
      }
      
      shadow.querySelector('#mg-explorer-close-button').onclick = metagraphCloseExplorer;
      
      /************/
      /* POC Code */
      /************/

      const buildTree = function(root, data, topLevel) {
	  if (topLevel) {
              root.innerHTML = '';
              const treeWidgetDiv = document.createElement('div');
              treeWidgetDiv.className = 'treewidget';
              root.appendChild(treeWidgetDiv);
              const ul = document.createElement('ul');
              treeWidgetDiv.appendChild(ul);
              buildTree(ul, data, false);
              
              const toggler = root.getElementsByClassName('caret');
              for (let i = 0; i < toggler.length; i++) {
		  toggler[i].addEventListener('click', function() {
                      this.parentElement.querySelector('.nested').classList.toggle('active');
                      this.classList.toggle('caret-down');
		  });
              }
	  } else {
              for (let name in data) {
		  if (data.hasOwnProperty(name)) {
                      const li = document.createElement('li');
                      const props = data[name];
                      if ('children' in props) {
			  const caret = document.createElement('span');
			  caret.className = 'caret';
			  caret.innerHTML = name;
			  li.appendChild(caret);
			  const ul = document.createElement('ul');
			  ul.className = 'nested';
			  li.appendChild(ul);
			  root.appendChild(li);
			  buildTree(ul, props['children'], false);
                      } else {
			  li.innerHTML = name;
			  root.appendChild(li);
                      }
		  }
              }
	  }
      }

      shadow.close = shadow.querySelector('.close');
      shadow.viewTypes = shadow.querySelector('#viewTypeTypes1');
      shadow.viewTranslators = shadow.querySelector('#viewTypeTranslators2');
      shadow.viewAlgorithms = shadow.querySelector('#viewTypeAlgorithms3');
      shadow.pluginsDropDown = shadow.querySelector('#pluginsDropDown');
      shadow.abstractDropDown = shadow.querySelector('#abstractDropDown');
      shadow.display = shadow.querySelector('#display');

      plugins.forEach(function(plug) {
	  const op = document.createElement('option');
	  op.value = plug;
	  op.innerHTML = plug;
	  shadow.pluginsDropDown.appendChild(op);
      });
      shadow.pluginsDropDown.onchange = function(event) {
	  allHandler(shadow);
      }
      
      abstractTypes.forEach(function(at) {
	  const op = document.createElement('option');
	  op.value = at;
	  op.innerHTML = at;
	  shadow.abstractDropDown.appendChild(op);
      });
      shadow.abstractDropDown.onchange = function(event) {
	  allHandler(shadow);
      }

      const radioHandler = function (event) {
	  if (shadow.viewTranslators.checked) {
              shadow.abstractDropDown.parentElement.style.visibility = null;
	  } else {
              shadow.abstractDropDown.parentElement.style.visibility = 'hidden';
	  }
	  allHandler(shadow);
      }
      shadow.viewTypes.onchange = radioHandler;
      shadow.viewTranslators.onchange = radioHandler;
      shadow.viewAlgorithms.onchange = radioHandler;
      shadow.close.onclick = function (event) {
	  shadow.websocket.send(JSON.stringify({function: 'close'}));
	  shadow.websocket.close();
	  // Remove everything as part of cleanup
	  shadow.innerHTML = '';
      }
      
      const allHandler = function(shadow) {
	  const kwargs = {filters: {}};
	  const pluginFilter = shadow.pluginsDropDown.value;
	  if (pluginFilter != '---') {
              kwargs['filters']['plugin'] = pluginFilter;
	  }
	  
	  if (shadow.viewTypes.checked) {
              shadow.display.innerHTML = '';
              shadow.websocket.send(JSON.stringify({function: 'list_types', kwargs: kwargs}));
	  } else if (shadow.viewTranslators.checked) {
              shadow.display.innerHTML = '';
              kwargs['source_type'] = shadow.abstractDropDown.value;
              shadow.websocket.send(JSON.stringify({function: 'list_translators', kwargs: kwargs}));
	  } else if (shadow.viewAlgorithms.checked) {
              shadow.display.innerHTML = '';
              shadow.websocket.send(JSON.stringify({function: 'list_algorithms', kwargs: kwargs}));
	  }
      }      
            
      /*************************************/
      /* Translation Graph Initializations */
      /*************************************/
      
      require.config({paths: {d3: 'https://d3js.org/d3.v5.min'}});
      
      const concreteTypeToAbstractType = Object.keys(abstractTypeToConcreteTypes).reduce((accumulator, abstractType) => {
	  Object.keys(abstractTypeToConcreteTypes[abstractType].children).forEach(concreteType => {
	      accumulator[concreteType] = abstractType;
	  });
	  return accumulator;
      }, {})

      const abstractTypeDropdown = shadow.querySelector('#mg-translation-graph-abstract-type-dropdown');
      abstractTypes.forEach(abstractType => {
          const optionElement = document.createElement('option');
          optionElement.setAttribute('value', abstractType);
          optionElement.innerHTML = abstractType;
	  abstractTypeDropdown.append(optionElement);
      });
      
      const loadTranslationGraph = (translationGraphData) => {

          console.log(`translationGraphData ${JSON.stringify(translationGraphData)}`); // TODO remove this
	  
	  require(['d3'], (d3) => {
	      
              // DOM Initializations
              const plotContainer = shadow.querySelector('div#mg-translation-graph-svg-container');
              const svg = d3.select(plotContainer.querySelector('svg#mg-translation-graph-svg'));
	      svg.selectAll('g').remove();
              svg
		  .attr('width', `${plotContainer.clientWidth}px`)
		  .attr('height', `${plotContainer.clientHeight}px`);
              const svgWidth = parseFloat(svg.style('width'));
              const svgHeight = parseFloat(svg.style('height'));
              const zoomGroup = svg.append('g').attr('class', `zoom-group-${plotContainer.id}`);
              const edgeGroup = zoomGroup.append('g').attr('class', `edge-group`);
              const nodeGroup = zoomGroup.append('g').attr('class', `node-group`);
	      const tooltipDiv = d3.select(plotContainer.querySelector('div#mg-translation-graph-tooltip'));
	      tooltipDiv.style('opacity', 0);

	      // Dropdown Initializations
	      const primaryConcreteTypes = Object.keys(translationGraphData.result.primary_types);
	      const secondaryConcreteTypes = Object.keys(translationGraphData.result.secondary_types);
	      const allConcreteTypes = primaryConcreteTypes.concat(secondaryConcreteTypes);
	      const startConcreteTypeDropdown = shadow.querySelector('#mg-translation-graph-start-concrete-type-dropdown');
	      removeAllChildNodes(startConcreteTypeDropdown);
	      const endConcreteTypeDropdown = shadow.querySelector('#mg-translation-graph-end-concrete-type-dropdown');
	      removeAllChildNodes(endConcreteTypeDropdown);
	      allConcreteTypes.forEach(concreteType => {
		  const startOptionElement = document.createElement('option');
		  startOptionElement.setAttribute('value', concreteType);
		  startOptionElement.innerHTML = concreteType;
		  startConcreteTypeDropdown.append(startOptionElement);
		  const endOptionElement = document.createElement('option');
		  endOptionElement.setAttribute('value', concreteType);
		  endOptionElement.innerHTML = concreteType;
		  endConcreteTypeDropdown.append(endOptionElement);
	      });
	      startConcreteTypeDropdown.selectedIndex = 0;
	      endConcreteTypeDropdown.selectedIndex = 1;
	      
              // Force Directed Graph Initializations
              const alphaDecay = 0.0;
              const velocityDecay = 0.9;
              const paddingBetweenNodes = 100;
              const initialLinkAlpha = 0.005;
              const linkAlphaDecay = 0.005;
              let linkAlpha = initialLinkAlpha;
              const simulation = d3.forceSimulation()
		    .alphaDecay(alphaDecay)
		    .velocityDecay(velocityDecay);
              const drag = d3.drag();
              
              // Edge Visualization
              const edgeData = [];
	      const primary_translators = Object.keys(translationGraphData.result.primary_translators);
	      const secondary_translators = Object.keys(translationGraphData.result.secondary_translators);
	      primary_translators.forEach((edge) => {
		  const [src, dst] = edge.split(' -> ');
		  const datum = {src, dst, translatorOrder: 'primary'};
		  edgeData.push(datum);
	      });
	      secondary_translators.forEach((edge) => {
		  const [src, dst] = edge.split(' -> ');
		  edgeData.push({src, dst, translatorOrder: 'secondary'});
	      });
	      const edgeByNodes = {};
	      allConcreteTypes.forEach(concreteType => {
		  edgeByNodes[concreteType] = {};
	      });
	      edgeData.forEach(edge => {
		  const {src, dst} = edge;
		  edgeByNodes[src][dst] = edge;
	      });
	      const edgeConcreteTypesToLineId = (srcConcreteType, dstConcreteType) => {
		  return `${srcConcreteType}-${dstConcreteType}-line`; 
	      };
              const edgeEnterSelection = edgeGroup
		    .selectAll('line')
		    .data(edgeData)
		    .enter()
		    .append('line')
		    .attr('class', 'mg-translation-graph-edge')
		    .attr('id', datum => edgeConcreteTypesToLineId(datum.src, datum.dst))
		    .classed('mg-translation-graph-primary-edge', datum => datum.translatorOrder === 'primary')
		    .classed('mg-translation-graph-secondary-edge', datum => datum.translatorOrder === 'secondary')
		    .attr('marker-end','url(#mg-translation-graph-edge-arrowhead)');

              // Node Visualization
	      const nodeIdToProperties = {};
	      primaryConcreteTypes.forEach(concreteType => {
		  nodeIdToProperties[concreteType] = {id: concreteType, concreteTypeOrder: 'primary'};
	      });
	      secondaryConcreteTypes.forEach(concreteType => {
		  nodeIdToProperties[concreteType] = {id: concreteType, concreteTypeOrder: 'secondary'};
	      });
	      const concreteTypeNameToCircleId = concreteTypeName => `${concreteTypeName}-circle`
              const nodeData = Object.values(nodeIdToProperties);
	      const nodeDataJoin = nodeGroup
		    .selectAll('circle')
		    .data(nodeData);
              const nodeEnterSelection = nodeDataJoin
		    .enter()
		    .append('circle')
		    .attr('id', datum => concreteTypeNameToCircleId(datum.id))
		    .on('mouseover', datum => {
			const [x, y] = absoluteXYOffset(shadow.querySelector(`#${d3.event.target.id}`));
			tooltipDiv
			    .style('opacity', .9)
			    .html(Object.keys(datum).map(key => `<p>${key}: ${datum[key]}</p>`).reduce((a,b) => a.concat(b)))
			    .style('left', x + 10 + 'px')
			    .style('top', y + 10 + 'px');
		    })
		    .on('mouseout', datum => {
			tooltipDiv
			    .style('opacity', 0);
		    })
		    .attr('class', 'mg-translation-graph-node');
              const nodeForwardNeighbors = Object.keys(nodeIdToProperties).reduce((accumulator, nodeId) => {
		  accumulator[nodeId] = [];
		  return accumulator;
              }, {});
              edgeData.forEach((edge) => {
		  nodeForwardNeighbors[edge.src].push(edge.dst);
	      });
              const nodeTextEnterSelection = nodeDataJoin
		    .enter()
		    .append('text')
		    .attr('class', datum => datum.concreteTypeOrder === 'primary' ? 'mg-translation-graph-node-text-primary' : 'mg-translation-graph-node-text-secondary')
                    .html(datum => datum.id);

	      // Dropdown Functionality
	      const highlightConcreteTypeWithClass = (concreteTypeName, className) => {
		  nodeGroup.selectAll('.mg-translation-graph-node').classed(className, false);
		  const concreteTypeToHighlightSelector = `#${concreteTypeNameToCircleId(concreteTypeName)}`;
		  nodeGroup.select(concreteTypeToHighlightSelector).classed(className, true);
	      };
	      const requestTranslationPath = () => {
		  const startConcreteType = startConcreteTypeDropdown.value;
		  const startAbstractType = concreteTypeToAbstractType[startConcreteType];
		  const endConcreteType = endConcreteTypeDropdown.value;
		  const endAbstractType = concreteTypeToAbstractType[endConcreteType];;
		  kwargs = {
		      src_abstract: startAbstractType,
		      src_concrete: startConcreteType,
		      dst_abstract: endAbstractType,
		      dst_concrete: endConcreteType,
		      overall_abstract: abstractTypeDropdown.value,
		  }
		  shadow.websocket.send(JSON.stringify({function: 'solve_translator', kwargs: kwargs}));
	      };
	      startConcreteTypeDropdown.onchange = (event) => {
		  highlightConcreteTypeWithClass(event.target.value, 'mg-translation-graph-start-node')
		  requestTranslationPath();
	      };
	      endConcreteTypeDropdown.onchange = (event) => {
		  highlightConcreteTypeWithClass(event.target.value, 'mg-translation-graph-end-node')
		  requestTranslationPath();
	      };
	      highlightConcreteTypeWithClass(startConcreteTypeDropdown.value, 'mg-translation-graph-start-node');
	      highlightConcreteTypeWithClass(endConcreteTypeDropdown.value, 'mg-translation-graph-end-node');
	      requestTranslationPath();
	      highlightTranslationGraphPath = (path) => {
		  edgeGroup.selectAll('.mg-translation-graph-highlighted-edge').classed('mg-translation-graph-highlighted-edge', false);
		  for(let i=0; i < path.length - 1; i++) {
		      const srcConcreteType = path[i];
		      const dstConcreteType = path[i+1];
		      const edgeToHighlightSelector = `#${edgeConcreteTypesToLineId(srcConcreteType, dstConcreteType)}`;
		      edgeGroup.select(edgeToHighlightSelector).classed('mg-translation-graph-highlighted-edge', true);
		  }
		  const displayTextDiv = shadow.querySelector('div#mg-translation-graph-path-display-text');
		  removeAllChildNodes(displayTextDiv);
		  path.forEach((concreteType, i) => {
		      const divElement = document.createElement('div');
		      divElement.classList.add('mg-translation-graph-path-display-text-path-node');
		      if (i === 0) {
			  divElement.setAttribute('id', 'mg-translation-graph-path-display-text-path-start-node');
		      } else if (i === path.length-1) {
			  divElement.setAttribute('id', 'mg-translation-graph-path-display-text-path-end-node');
		      }
		      divElement.innerHTML = concreteType;
		      displayTextDiv.append(divElement);
		      if (i !== path.length-1) {
			  const arrowDiv = document.createElement('div');
			  arrowDiv.innerHTML = '&darr;';
			  displayTextDiv.append(arrowDiv)
		      }
		  })
	      };

              // Zooming
              const zoom = d3.zoom().on('zoom', () => {
		  zoomGroup
                      .attr('transform', d3.event.transform);
              });
              svg.call(zoom);
              
              // Force Directed Graph Visualization
              drag.on('drag', (d,i) => {
		  d.x += d3.event.dx;
		  d.y += d3.event.dy;
		  linkAlpha = initialLinkAlpha;
              });
              const linkForce = () => {
		  linkAlpha = linkAlpha * (1-linkAlphaDecay);
		  nodeData.forEach(datum => {
                      const forwardNeighborIds = nodeForwardNeighbors[datum.id];
                      const neighborIds = (forwardNeighborIds.length > 0) ? forwardNeighborIds : Object.keys(nodeIdToProperties);
                      if (neighborIds.length > 0) {
			  const neighborMeanX = mean(neighborIds.map(neighborId => nodeIdToProperties[neighborId].x));
			  const neighborMeanY = mean(neighborIds.map(neighborId => nodeIdToProperties[neighborId].y));
			  const newX = datum.x * (1-linkAlpha) + linkAlpha * neighborMeanX;
			  const newY = datum.y * (1-linkAlpha) + linkAlpha * neighborMeanY;
			  datum.x = newX;
			  datum.y = newY;
                      }
		  });
              };
              simulation
		  .force('center', d3.forceCenter(svgWidth / 2, svgHeight / 2))
		  .force('collide', d3.forceCollide(paddingBetweenNodes).strength(0.25).iterations(200))
		  .force('links', linkForce)
		  .nodes(nodeData).on('tick', () => {
	              nodeEnterSelection
			  .attr('cx', datum => datum.x)
			  .attr('cy', datum => datum.y)
			  .call(drag);
		      nodeTextEnterSelection
			  .attr('x', datum => datum.x + 10)
			  .attr('y', datum => datum.y);
	              edgeEnterSelection
			  .attr('x1', datum => nodeIdToProperties[datum.src].x)
			  .attr('y1', datum => nodeIdToProperties[datum.src].y)
			  .attr('x2', datum => nodeIdToProperties[datum.dst].x)
			  .attr('y2', datum => nodeIdToProperties[datum.dst].y);
		  })
		  .restart();
	  });
	  
      };
      const updateTranslationGraph = (translationGraphData) => {
	  callAfterDOMUpdated(() => loadTranslationGraph(translationGraphData));
      }
      const requestTranslationGraphAbstractTypeUpdate = () => shadow.websocket.send(JSON.stringify({function: 'list_translators', kwargs: {source_type: abstractTypeDropdown.value}}))
      abstractTypeDropdown.onchange = requestTranslationGraphAbstractTypeUpdate;
      shadow.websocket.onopen = requestTranslationGraphAbstractTypeUpdate;
      
  })({RESOLVER_DATA})
  
</script>
