<div id="{DIV_ID}" />

<h3 style="color: red">Metagraph explorer load error. Please try again.</h3>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js"></script>

<script>

  (({port, divId, shadowInnerHTML, abstractTypeToConcreteTypes, pluginData, abstractTypes}) => {

      if (typeof require === "undefined") {
          setTimeout(this, 200, port, divId, shadowInnerHTML, abstractTypeToConcreteTypes, pluginData, abstractTypes);
          return;
      }

      /*******************/
      /* Misc. Utilities */
      /*******************/
      
      const sum = inputArray => inputArray.reduce((a, b) => a + b, 0);
      const mean = inputArray => sum(inputArray) / inputArray.length;

      const removeAllChildNodes = (parent) => {
	  while (parent.firstChild) {
              parent.removeChild(parent.firstChild);
	  }
      }

      const callAfterDOMUpdated = (func) => {
	  // Calls function after the DOM is updated to prevent non-deterministic results when grabbing element attributes, e.g. height, during transitions and animations
	  const intermediateFunc = () => window.requestAnimationFrame(func);
	  window.requestAnimationFrame(intermediateFunc);
      };

      const absoluteXYOffset = (element) => {
	  const rect = element.getBoundingClientRect();
	  const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
	  const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
	  return [rect.left + scrollLeft, rect.top + scrollTop]
      }
      
      /******************************/
      /* Shadow DOM Initializations */
      /******************************/
      
      const div = document.getElementById(divId);
      const shadow = div.attachShadow({mode: 'open'});
      shadow.innerHTML = shadowInnerHTML;
      shadow.websocket = new WebSocket(`ws://127.0.0.1:${port}/`);
      shadow.websocket.onerror = () => {
	  removeAllChildNodes(shadow);
	  shadow.innerHTML = `Websocket connection to ws://127.0.0.1:${port}/ failed.`;
      };
      shadow.websocket.owner = shadow; // Add back-reference on websocket

      let highlightTranslationGraphPath = (path) => {};
      
      // Listen for websocket messages
      shadow.websocket.onmessage = function (event) {
	  data = JSON.parse(event.data);
	  switch (data.function) {
	  case "list_types":
	      updateTypeExplorer(data);
	      // below is used by POC only
              buildTree(shadow.display, data.result, true);
              break;
	  case "list_translators":
              updateTranslationGraph(data);
              // below is used by POC only
              shadow.display.innerHTML = "";
              const treeWidgetDiv = document.createElement('div');
              treeWidgetDiv.className = "treewidget";
              shadow.display.appendChild(treeWidgetDiv);
              const ul = document.createElement('ul');
              treeWidgetDiv.appendChild(ul);
              const primary = document.createElement('li');
              primary.innerHTML = "Primary: " + Object.keys(data.result['primary_types']);
              ul.appendChild(primary);
              const secondary = document.createElement('li');
              secondary.innerHTML = "Secondary: " + Object.keys(data.result['secondary_types']);
              ul.appendChild(secondary);
              const trans = document.createElement('li');
              ul.appendChild(trans);
              const caret = document.createElement('span');
              caret.className = 'caret caret-down';
              caret.innerHTML = 'Translators'
              trans.appendChild(caret);
              const transUL = document.createElement('ul')
              transUL.className = 'nested active';
              trans.appendChild(transUL);
              for (var pt in data.result['primary_translators']) {
                  // var t = data.result['primary_translators'][pt];
                  var t2 = document.createElement('li');
                  t2.innerHTML = pt;
                  transUL.appendChild(t2);
              }
              caret.addEventListener("click", function() {
                  this.parentElement.querySelector(".nested").classList.toggle("active");
                  this.classList.toggle("caret-down");
              });
              break;
	  case "list_algorithms":
	      updateAlgorithmExplorer(data);
	      // below is used by POC only
              buildTree(shadow.display, data.result, true);
              break;
	  case 'solve_translator':
	      if (data.input_kwargs.overall_abstract === abstractTypeDropdown.value) {
		  highlightTranslationGraphPath(data.result);
	      }
	      break;
	  default:
              console.error('unsupported event', data);
	  }
      };
      
      /**********************************/
      /* Explorer Tab Selection Buttons */
      /**********************************/
      
      const metagraphActivateExplorerTab = (clickedElement, explorerTabId) => {
	  for (const navigationBarLi of shadow.querySelectorAll(`#mg-explorer-navigation-bar li`)) {
              navigationBarLi.classList.remove('active');
	  }
	  clickedElement.closest('li').classList.add('active');
	  for (const explorerTab of shadow.querySelectorAll('.mg-explorer-tab')) {
              explorerTab.classList.remove('active');
	  }
	  const currentExplorerTab = shadow.querySelector(`#${explorerTabId}`);
	  currentExplorerTab.classList.add('active');
      };
      
      shadow.querySelector('#mg-translation-explorer-selector').onclick = (event) => metagraphActivateExplorerTab(event.target, 'mg-translation-explorer');
      shadow.querySelector('#mg-type-explorer-selector').onclick = (event) => metagraphActivateExplorerTab(event.target, 'mg-type-explorer');
      shadow.querySelector('#mg-algorithm-explorer-selector').onclick = (event) => metagraphActivateExplorerTab(event.target, 'mg-algorithm-explorer');
      shadow.querySelector('#mg-algorithm-type-translation-explorer-selector').onclick = (event) => metagraphActivateExplorerTab(event.target, 'mg-algorithm-type-translation-explorer');
      shadow.querySelector('#mg-plugin-explorer-selector').onclick = (event) => metagraphActivateExplorerTab(event.target, 'mg-plugin-explorer');
      
      const metagraphCloseExplorer = () => {
	  shadow.websocket.send(JSON.stringify({function: 'close'}));
	  shadow.websocket.close();
	  removeAllChildNodes(shadow);
      }
      
      shadow.querySelector('#mg-explorer-close-button').onclick = metagraphCloseExplorer;

      /*****************/
      /* Type Explorer */
      /*****************/
      
      const updateTypeExplorer = (typeData) => {
	  const typeExplorerContentDiv = shadow.querySelector('#mg-type-explorer-content');
	  removeAllChildNodes(typeExplorerContentDiv);
	  const abstractTypeDataLookup = typeData.result;
	  Object.keys(abstractTypeDataLookup).forEach(abstractType => {
              const abstractTypeElement = document.createElement('p');
	      abstractTypeElement.classList.add('mg-type-explorer-abstract-type');
              abstractTypeElement.innerHTML = abstractType;
	      typeExplorerContentDiv.append(abstractTypeElement);
	      const concreteTypeDataLookup = abstractTypeDataLookup[abstractType].children;
	      const concreteTypes = Object.keys(concreteTypeDataLookup);
	      const concreteTypeContainer = document.createElement('div');
	      concreteTypeContainer.classList.add('mg-type-explorer-concrete-type-container');
	      concreteTypes.forEach(concreteType => {
		  const concreteTypeElement = document.createElement('p');
		  concreteTypeElement.classList.add('mg-type-explorer-concrete-type');
		  concreteTypeElement.innerHTML = concreteType;
		  concreteTypeContainer.append(concreteTypeElement);
	      });
	      typeExplorerContentDiv.append(concreteTypeContainer);
	      abstractTypeElement.onclick = (event) => {
		  abstractTypeElement.classList.toggle('active');
		  concreteTypeContainer.classList.toggle('active');
	      };
	  });
      }
      const requestTypeExplorerUpdate = () => shadow.websocket.send(JSON.stringify({function: 'list_types', kwargs: {}}));
      
      /**********************/
      /* Algorithm Explorer */
      /**********************/
      
      const updateAlgorithmExplorer = (algorithmData) => {
	  const algorithmExplorerContentDiv = shadow.querySelector('#mg-algorithm-explorer-content');
	  removeAllChildNodes(algorithmExplorerContentDiv);
	  algorithmExplorerContentDiv.classList.add('mg-explorer-tree-widget-container');
	  const buildAlgorithmTreeWidget = (root, data) => {
	      for (let name in data) {
                  if (data.hasOwnProperty(name)) {
		      const props = data[name];
		      const hasChildren = 'children' in props;
		      if (hasChildren) {
                          const label = document.createElement('p');
			  label.classList.add('mg-explorer-tree-widget-label');
                          label.innerHTML = name;
                          root.appendChild(label);
                          const container = document.createElement('div');
                          container.className = 'mg-explorer-tree-widget-subcontainer';
			  root.append(container);
			  label.onclick = (event) => {
			      label.classList.toggle('active');
			      container.classList.toggle('active');
			  };
			  const childrenData = props['children'];
                          buildAlgorithmTreeWidget(container, childrenData);
		      } else {
                          const leaf = document.createElement('p');
			  leaf.classList.add('mg-explorer-tree-widget-leaf');
                          leaf.innerHTML = name;
                          root.appendChild(leaf);
		      }
                  }
	      }
	  };
	  buildAlgorithmTreeWidget(algorithmExplorerContentDiv, algorithmData.result);
      };
      const requestAlgorithmExplorerUpdate = () => shadow.websocket.send(JSON.stringify({function: 'list_algorithms', kwargs: {}}));

      /*******************/
      /* Plugin Explorer */
      /*******************/

      console.log(`pluginData ${JSON.stringify(pluginData)}`);
      
      /************/
      /* POC Code */
      /************/

      const buildTree = function(root, data, topLevel) {
          if (topLevel) {
              root.innerHTML = '';
              const treeWidgetDiv = document.createElement('div');
              treeWidgetDiv.className = 'treewidget';
              root.appendChild(treeWidgetDiv);
              const ul = document.createElement('ul');
              treeWidgetDiv.appendChild(ul);
              buildTree(ul, data, false);
              
              const toggler = root.getElementsByClassName('caret');
              for (let i = 0; i < toggler.length; i++) {
                  toggler[i].addEventListener('click', function() {
                      this.parentElement.querySelector('.nested').classList.toggle('active');
                      this.classList.toggle('caret-down');
                  });
              }
          } else {
              for (let name in data) {
                  if (data.hasOwnProperty(name)) {
                      const li = document.createElement('li');
                      const props = data[name];
                      if ('children' in props) {
                          const caret = document.createElement('span');
                          caret.className = 'caret';
                          caret.innerHTML = name;
                          li.appendChild(caret);
                          const ul = document.createElement('ul');
                          ul.className = 'nested';
                          li.appendChild(ul);
                          root.appendChild(li);
                          buildTree(ul, props['children'], false);
                      } else {
                          li.innerHTML = name;
                          root.appendChild(li);
                      }
                  }
              }
          }
      }

      // shadow.close = shadow.querySelector('.close');
      shadow.viewTypes = shadow.querySelector('#viewTypeTypes1');
      shadow.viewTranslators = shadow.querySelector('#viewTypeTranslators2');
      shadow.viewAlgorithms = shadow.querySelector('#viewTypeAlgorithms3');
      shadow.pluginsDropDown = shadow.querySelector('#pluginsDropDown');
      shadow.abstractDropDown = shadow.querySelector('#abstractDropDown');
      shadow.display = shadow.querySelector('#display');

      const plugins = Object.keys(pluginData);
      plugins.forEach(function(plug) {
          const op = document.createElement('option');
          op.value = plug;
          op.innerHTML = plug;
          shadow.pluginsDropDown.appendChild(op);
      });
      shadow.pluginsDropDown.onchange = function(event) {
          allHandler(shadow);
      }
      
      abstractTypes.forEach(function(at) {
          const op = document.createElement('option');
          op.value = at;
          op.innerHTML = at;
          shadow.abstractDropDown.appendChild(op);
      });
      shadow.abstractDropDown.onchange = function(event) {
          allHandler(shadow);
      }

      const radioHandler = function (event) {
          if (shadow.viewTranslators.checked) {
              shadow.abstractDropDown.parentElement.style.visibility = null;
          } else {
              shadow.abstractDropDown.parentElement.style.visibility = 'hidden';
          }
          allHandler(shadow);
      }
      shadow.viewTypes.onchange = radioHandler;
      shadow.viewTranslators.onchange = radioHandler;
      shadow.viewAlgorithms.onchange = radioHandler;
      
      const allHandler = function(shadow) {
          const kwargs = {filters: {}};
          const pluginFilter = shadow.pluginsDropDown.value;
          if (pluginFilter != '---') {
              kwargs['filters']['plugin'] = pluginFilter;
          }

          if (shadow.viewTypes.checked) {
              shadow.display.innerHTML = '';
              shadow.websocket.send(JSON.stringify({function: 'list_types', kwargs: kwargs}));
          } else if (shadow.viewTranslators.checked) {
              shadow.display.innerHTML = '';
              kwargs['source_type'] = shadow.abstractDropDown.value;
              shadow.websocket.send(JSON.stringify({function: 'list_translators', kwargs: kwargs}));
          } else if (shadow.viewAlgorithms.checked) {
              shadow.display.innerHTML = '';
              shadow.websocket.send(JSON.stringify({function: 'list_algorithms', kwargs: kwargs}));
          }
      }      
      
      /*************************************/
      /* Translation Graph Initializations */
      /*************************************/
      
      require.config({paths: {d3: 'https://d3js.org/d3.v5.min'}});
      
      const concreteTypeToAbstractType = Object.keys(abstractTypeToConcreteTypes).reduce((accumulator, abstractType) => {
	  Object.keys(abstractTypeToConcreteTypes[abstractType].children).forEach(concreteType => {
	      accumulator[concreteType] = abstractType;
	  });
	  return accumulator;
      }, {})

      const abstractTypeDropdown = shadow.querySelector('#mg-translation-graph-abstract-type-dropdown');
      abstractTypes.forEach(abstractType => {
          const optionElement = document.createElement('option');
          optionElement.setAttribute('value', abstractType);
          optionElement.innerHTML = abstractType;
	  abstractTypeDropdown.append(optionElement);
      });

      let simulation = {stop: () => {}}
      const loadTranslationGraph = (translationGraphData) => {
	  
	  require(['d3'], (d3) => {

	      // D3 Extensions
	      d3.selection.prototype.moveToFront = function() {
		  return this.each(function() {
		      if (this.parentNode !== null) {
			  this.parentNode.appendChild(this);
		      }
		  });
	      };
	      
              // DOM Initializations
              const plotContainer = shadow.querySelector('div#mg-translation-graph-svg-container');
              const svg = d3.select(plotContainer.querySelector('svg#mg-translation-graph-svg'));
	      svg.selectAll('g').remove();
              svg
		  .attr('width', `${plotContainer.clientWidth}px`)
		  .attr('height', `${plotContainer.clientHeight}px`);
              const svgWidth = parseFloat(svg.style('width'));
              const svgHeight = parseFloat(svg.style('height'));
              const zoomGroup = svg.append('g').attr('class', `zoom-group-${plotContainer.id}`);
              const edgeGroup = zoomGroup.append('g').attr('class', `edge-group`);
              const nodeGroup = zoomGroup.append('g').attr('class', `node-group`);
	      const tooltipDiv = d3.select(plotContainer.querySelector('div#mg-translation-graph-tooltip'));

	      // Dropdown Initializations
	      const primaryConcreteTypes = Object.keys(translationGraphData.result.primary_types);
	      const secondaryConcreteTypes = Object.keys(translationGraphData.result.secondary_types);
	      const allConcreteTypes = primaryConcreteTypes.concat(secondaryConcreteTypes);
	      const startConcreteTypeDropdown = shadow.querySelector('#mg-translation-graph-start-concrete-type-dropdown');
	      removeAllChildNodes(startConcreteTypeDropdown);
	      const endConcreteTypeDropdown = shadow.querySelector('#mg-translation-graph-end-concrete-type-dropdown');
	      removeAllChildNodes(endConcreteTypeDropdown);
	      allConcreteTypes.forEach(concreteType => {
		  const startOptionElement = document.createElement('option');
		  startOptionElement.setAttribute('value', concreteType);
		  startOptionElement.innerHTML = concreteType;
		  startConcreteTypeDropdown.append(startOptionElement);
		  const endOptionElement = document.createElement('option');
		  endOptionElement.setAttribute('value', concreteType);
		  endOptionElement.innerHTML = concreteType;
		  endConcreteTypeDropdown.append(endOptionElement);
	      });
	      
              // Force Directed Graph Initializations
	      const nodeTextHorizontalOffset = 25;
	      const nodeTextBoundingBoxPadding = 5;
              const alphaDecay = 0.05;
              const velocityDecay = 0.9;
              const paddingBetweenNodes = 100;
              const initialLinkAlpha = 0.005;
              const linkAlphaDecay = 0.005;
              let linkAlpha = initialLinkAlpha;
	      simulation.stop();
              simulation = d3.forceSimulation()
		    .alphaDecay(alphaDecay)
		    .velocityDecay(velocityDecay);
              const drag = d3.drag();
              
              // Edge Visualization
              const edgeData = [];
	      for (edgeString in translationGraphData.result.primary_translators) {
		  const [src, dst] = edgeString.split(' -> ');
		  const datum = Object.assign({src, dst, translatorOrder: 'primary'}, translationGraphData.result.primary_translators[edgeString]);
		  edgeData.push(datum);
	      };
	      for (edgeString in translationGraphData.result.secondary_translators) {
		  const [src, dst] = edgeString.split(' -> ');
		  const datum = Object.assign({src, dst, translatorOrder: 'secondary'}, translationGraphData.result.secondary_translators[edgeString]);
		  edgeData.push(datum);
	      };
	      const edgeByNodes = {};
	      allConcreteTypes.forEach(concreteType => {
		  edgeByNodes[concreteType] = {};
	      });
	      edgeData.forEach(edge => {
		  const {src, dst} = edge;
		  edgeByNodes[src][dst] = edge;
	      });
	      const edgeConcreteTypesToLineId = (srcConcreteType, dstConcreteType) => {
		  return `${srcConcreteType}-${dstConcreteType}-line`; 
	      };
              const edgeEnterSelection = edgeGroup
		    .selectAll('path')
		    .data(edgeData)
		    .enter()
		    .append('path')
		    .attr('class', 'mg-translation-graph-edge')
		    .attr('id', datum => edgeConcreteTypesToLineId(datum.src, datum.dst))
		    .classed('mg-translation-graph-primary-edge', datum => datum.translatorOrder === 'primary')
		    .classed('mg-translation-graph-secondary-edge', datum => datum.translatorOrder === 'secondary')
		    .attr('marker-end','url(#mg-translation-graph-edge-arrowhead)');

              // Node Visualization
	      const nodeIdToProperties = {};
	      primaryConcreteTypes.forEach(concreteType => {
		  nodeIdToProperties[concreteType] = {id: concreteType, concreteTypeOrder: 'primary'};
	      });
	      secondaryConcreteTypes.forEach(concreteType => {
		  nodeIdToProperties[concreteType] = {id: concreteType, concreteTypeOrder: 'secondary'};
	      });
	      const concreteTypeNameToCircleId = concreteTypeName => `${concreteTypeName}-circle`
              const nodeData = Object.values(nodeIdToProperties);
	      const nodeDataJoin = nodeGroup
		    .selectAll('circle')
		    .data(nodeData);
	      const showToolTip = function(datum) {
		  const [x, y] = absoluteXYOffset(shadow.querySelector(`#${d3.select(this).node().id}`));
		  tooltipDiv
		      .style('opacity', .9)
		      .html(`<div id="mg-translation-graph-tooltip-content">
<p>Name: ${datum.id}</p>
<p>Order: ${datum.concreteTypeOrder}</p>
</div>`)
		      .style('left', x + 10 + 'px')
		      .style('top', y + 10 + 'px');
	      };
	      const hideToolTip = datum => {
			tooltipDiv
			    .style('opacity', 0);
	      };
              const nodeEnterSelection = nodeDataJoin
		    .enter()
		    .append('circle')
		    .attr('id', datum => concreteTypeNameToCircleId(datum.id))
		    .on('mouseover', showToolTip)
		    .on('mouseout', hideToolTip)
		    .attr('class', 'mg-translation-graph-node')
		    .call(drag);
              const nodeForwardNeighbors = Object.keys(nodeIdToProperties).reduce((accumulator, nodeId) => {
		  accumulator[nodeId] = [];
		  return accumulator;
              }, {});
              edgeData.forEach((edge) => {
		  nodeForwardNeighbors[edge.src].push(edge.dst);
	      });
	      const concreteTypeNameToTextElementId = concreteType => `${concreteType}-text-element`;
              const nodeTextEnterSelection = nodeDataJoin
		    .enter()
		    .append('text')
		    .attr('dx', nodeTextHorizontalOffset)
		    .attr('id', datum => concreteTypeNameToTextElementId(datum.id))
		    .attr('class', datum => datum.concreteTypeOrder === 'primary' ? 'mg-translation-graph-node-text-primary' : 'mg-translation-graph-node-text-secondary')
		    .on('mouseover', showToolTip)
		    .on('mouseout', hideToolTip)
                    .html(datum => datum.id);
	      const concreteTypeNameToTextElementBoundingBoxId = concreteType => `${concreteType}-text-element-bounding-box`;
              const nodeTextBoundingBoxEnterSelection = nodeDataJoin
		    .enter()
		    .append('rect')
		    .attr('id', datum => concreteTypeNameToTextElementBoundingBoxId(datum.id))
		    .attr('class', datum => datum.concreteTypeOrder === 'primary' ? 'mg-translation-graph-node-text-bounding-box-primary' : 'mg-translation-graph-node-text-bounding-box-secondary')
		    .classed('mg-translation-graph-node-text-bounding-box', true)
		    .on('mouseover', showToolTip)
		    .on('mouseout', hideToolTip)
                    .html(datum => datum.id);

	      // Dropdown Functionality
	      const highlightConcreteTypeWithClass = (concreteTypeName, className) => {
		  nodeGroup.selectAll('.mg-translation-graph-node').classed(className, false);
		  const concreteTypeToHighlightSelector = `#${concreteTypeNameToCircleId(concreteTypeName)}`;
		  nodeGroup.select(concreteTypeToHighlightSelector).classed(className, true);
	      };
	      const requestTranslationPath = () => {
		  const startConcreteType = startConcreteTypeDropdown.value;
		  const startAbstractType = concreteTypeToAbstractType[startConcreteType];
		  const endConcreteType = endConcreteTypeDropdown.value;
		  const endAbstractType = concreteTypeToAbstractType[endConcreteType];;
		  kwargs = {
		      src_abstract: startAbstractType,
		      src_concrete: startConcreteType,
		      dst_abstract: endAbstractType,
		      dst_concrete: endConcreteType,
		      overall_abstract: abstractTypeDropdown.value,
		  }
		  highlightConcreteTypeWithClass(startConcreteTypeDropdown.value, 'mg-translation-graph-start-node');
		  highlightConcreteTypeWithClass(endConcreteTypeDropdown.value, 'mg-translation-graph-end-node');
		  shadow.websocket.send(JSON.stringify({function: 'solve_translator', kwargs: kwargs}));
	      };
	      startConcreteTypeDropdown.onchange = (event) => {
		  requestTranslationPath();
	      };
	      endConcreteTypeDropdown.onchange = (event) => {
		  requestTranslationPath();
	      };
	      highlightTranslationGraphPath = (result) => {
		  const path = result.solution
		  edgeGroup.selectAll('.mg-translation-graph-highlighted-edge').classed('mg-translation-graph-highlighted-edge', false);
		  const displayTextDiv = shadow.querySelector('div#mg-translation-graph-path-display-text');
		  switch (result.result_type) {
		  case 'unsatisfiable':
		      displayTextDiv.innerHTML = '<p>Translation unsatisfiable.</p>'
		      break;
		  case 'null':
		      displayTextDiv.innerHTML = '<p>No translation needed.</p>'
		      break;
		  default:
		      for(let i=0; i < path.length - 1; i++) {
			  const srcConcreteType = path[i];
			  const dstConcreteType = path[i+1];
			  const edgeToHighlightSelector = `#${edgeConcreteTypesToLineId(srcConcreteType, dstConcreteType)}`;
			  edgeGroup.select(edgeToHighlightSelector).classed('mg-translation-graph-highlighted-edge', true);
		      }
		      removeAllChildNodes(displayTextDiv);
		      path.forEach((concreteType, i) => {
			  const divElement = document.createElement('div');
			  divElement.classList.add('mg-translation-graph-path-display-text-path-node');
			  if (i === 0) {
			      divElement.setAttribute('id', 'mg-translation-graph-path-display-text-path-start-node');
			  } else if (i === path.length-1) {
			      divElement.setAttribute('id', 'mg-translation-graph-path-display-text-path-end-node');
			  }
			  divElement.innerHTML = concreteType;
			  displayTextDiv.append(divElement);
			  if (i !== path.length-1) {
			      const arrowDiv = document.createElement('div');
			      arrowDiv.innerHTML = '&darr;';
			      displayTextDiv.append(arrowDiv)
			  }
		      })
		      break;
		  }
	      };
	      const filterByPluginDropdown = shadow.querySelector('#mg-translation-graph-filter-by-plugin-dropdown');
	      removeAllChildNodes(filterByPluginDropdown);
	      const pluginNames = Array.from(new Set(edgeData.map(edge => edge.plugin))).sort();
	      ['All Plugins'].concat(pluginNames).forEach(pluginName => {
	       	  const optionElement = document.createElement('option');
	       	  optionElement.setAttribute('value', pluginName);
	       	  optionElement.innerHTML = pluginName;
	       	  filterByPluginDropdown.append(optionElement);
	      });
	      const filterByPluginName = (pluginName) => {
		  edgeGroup
		      .selectAll('.mg-translation-graph-edge')
		      .classed('mg-translation-graph-hidden-edge', datum => pluginName !== 'All Plugins' && datum.plugin !== pluginName);
	      };
	      filterByPluginDropdown.onchange = (event) => {
		  const pluginName = event.target.value;
		  filterByPluginName(pluginName);
	      }
	      const hideTranslationPaths = () => {
		  shadow.querySelector('#mg-translation-graph-translation-path-solver-toggle-button').classList.remove('active');
		  shadow.querySelector('#mg-translation-graph-translation-path-solver-menu').classList.remove('active');
		  shadow.querySelector('#mg-translation-graph-path-solver-row').classList.remove('active');
		  edgeGroup.selectAll('.mg-translation-graph-highlighted-edge').classed('mg-translation-graph-highlighted-edge', false);
		  nodeGroup.selectAll('.mg-translation-graph-node')
		      .classed('mg-translation-graph-start-node', false)
		      .classed('mg-translation-graph-end-node', false);
	      };
	      const showTranslationPaths = () => {
		  shadow.querySelector('#mg-translation-graph-translation-path-solver-toggle-button').classList.add('active');
	       	  shadow.querySelector('#mg-translation-graph-translation-path-solver-menu').classList.add('active');
	       	  shadow.querySelector('#mg-translation-graph-path-solver-row').classList.add('active');
		  requestTranslationPath(); // TODO slow since sends another request with no path change
	      };
	      const deactivateFilterByPluginFilters = () => {
		  shadow.querySelector('#mg-translation-graph-filter-by-plugin-toggle-button').classList.remove('active');
		  shadow.querySelector('#mg-translation-graph-filter-by-plugin-menu').classList.remove('active');
		  filterByPluginName('All Plugins');
	      };
	      const activateFilterByPluginFilters = () => {
		  shadow.querySelector('#mg-translation-graph-filter-by-plugin-toggle-button').classList.add('active');
		  shadow.querySelector('#mg-translation-graph-filter-by-plugin-menu').classList.add('active');
		  filterByPluginName(filterByPluginDropdown.value);
	      };
	      const filterByPluginToggler = shadow.querySelector('#mg-translation-graph-filter-by-plugin-toggle-button');
	      filterByPluginToggler.onclick = (event) => {
	       	  hideTranslationPaths();
		  if (shadow.querySelector('#mg-translation-graph-filter-by-plugin-toggle-button').classList.contains('active')) {
		      deactivateFilterByPluginFilters();
		  } else {
		      activateFilterByPluginFilters();
		  }
	       };
	      const translationnPathSolverToggler = shadow.querySelector('#mg-translation-graph-translation-path-solver-toggle-button');
	      translationnPathSolverToggler.onclick = (event) => {
	       	  deactivateFilterByPluginFilters();
		  if (shadow.querySelector('#mg-translation-graph-translation-path-solver-toggle-button').classList.contains('active')) {
		      hideTranslationPaths();
		  } else {
	       	      showTranslationPaths();
		  }
	      };
	      
              // Force Directed Graph Visualization
              const linkForce = () => {
		  linkAlpha = linkAlpha * (1-linkAlphaDecay);
		  nodeData.forEach(datum => {
                      const forwardNeighborIds = nodeForwardNeighbors[datum.id];
                      const neighborIds = (forwardNeighborIds.length > 0) ? forwardNeighborIds : Object.keys(nodeIdToProperties);
                      if (neighborIds.length > 0) {
			  const neighborMeanX = mean(neighborIds.map(neighborId => nodeIdToProperties[neighborId].x));
			  const neighborMeanY = mean(neighborIds.map(neighborId => nodeIdToProperties[neighborId].y));
			  const newX = datum.x * (1-linkAlpha) + linkAlpha * neighborMeanX;
			  const newY = datum.y * (1-linkAlpha) + linkAlpha * neighborMeanY;
			  datum.x = newX;
			  datum.y = newY;
                      }
		  });
              };
	      const render = () => {
	          nodeEnterSelection
		      .attr('cx', datum => datum.x)
		      .attr('cy', datum => datum.y);
	          edgeEnterSelection
		      .attr('d', datum => {
			  const offset = 30;
			  const source = nodeIdToProperties[datum.src];
			  const destination = nodeIdToProperties[datum.dst];
			  const midpointX = mean([source.x, destination.x]);
			  const midpointY = mean([source.y, destination.y]);
			  const dx = (destination.x - source.x);
			  const dy = (destination.y - source.y);
			  const normalization = Math.sqrt((dx * dx) + (dy * dy));
			  const offSetX = midpointX + offset*(dy/normalization);
			  const offSetY = midpointY - offset*(dx/normalization);
			  return `M ${source.x}, ${source.y} S ${offSetX}, ${offSetY} ${destination.x}, ${destination.y}`;
		      });
		  nodeTextEnterSelection
		      .attr('x', datum => datum.x)
		      .attr('y', datum => datum.y);
		  nodeTextBoundingBoxEnterSelection
		      .attr('x', datum => {
			  const textElementId = concreteTypeNameToTextElementId(datum.id);
			  const textElementBBox = svg.select(`#${textElementId}`).node().getBBox();
			  const x = textElementBBox.x - nodeTextBoundingBoxPadding;
			  return x;
		      })
		      .attr('y', datum => {
			  const textElementId = concreteTypeNameToTextElementId(datum.id);
			  const textElementBBox = svg.select(`#${textElementId}`).node().getBBox();
			  const y = textElementBBox.y - nodeTextBoundingBoxPadding;
			  return y;
		      })
                      .attr('width', datum => {
			  const textElementId = concreteTypeNameToTextElementId(datum.id);
			  const textElementBBox = svg.select(`#${textElementId}`).node().getBBox();
			  return textElementBBox.width + 2 * nodeTextBoundingBoxPadding;
		      })
                      .attr('height', datum => {
			  const textElementId = concreteTypeNameToTextElementId(datum.id);
			  const textElementBBox = svg.select(`#${textElementId}`).node().getBBox();
			  return textElementBBox.height + 2 * nodeTextBoundingBoxPadding;
		      });
		  nodeTextEnterSelection.moveToFront();
	      };
              simulation
		  .force('center', d3.forceCenter(svgWidth / 2, svgHeight / 2))
		  .force('collide', d3.forceCollide(paddingBetweenNodes).strength(0.25).iterations(200))
		  .force('links', linkForce)
		  .nodes(nodeData).on('tick', render)
		  .alphaMin(0.001)
		  .restart();
	      
              // Zooming
              const zoom = d3.zoom().on('zoom', () => {
		  zoomGroup
                      .attr('transform', d3.event.transform);
              });
              svg.call(zoom);

	      // Drag & Drop
	      drag.on('drag', datum => {
		  linkAlpha = initialLinkAlpha;
		  datum.x += d3.event.dx;
		  datum.y += d3.event.dy;
		  simulation
		      .alpha(0.1)
		      .restart();
		  render();
              });
	  });
	  
      };
      const updateTranslationGraph = (translationGraphData) => {
	  callAfterDOMUpdated(() => loadTranslationGraph(translationGraphData));
      }
      const requestTranslationGraphAbstractTypeUpdate = () => shadow.websocket.send(JSON.stringify({function: 'list_translators', kwargs: {source_type: abstractTypeDropdown.value}}))
      abstractTypeDropdown.onchange = requestTranslationGraphAbstractTypeUpdate;

      shadow.websocket.onopen = () => {
	  requestTranslationGraphAbstractTypeUpdate();
	  requestTypeExplorerUpdate();
	  requestAlgorithmExplorerUpdate();
      }
      
  })({RESOLVER_DATA})
  
</script>
